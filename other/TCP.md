# TCP协议
## 引言
## TCP连接的建立与终止
### 连接建立与终止
tcpdump的输出
![](http://daheli.qiniudn.com/2017-06-08-14968166750175.jpg)

```
字段1415531521:1415531521(0)表示分组的序号是1415531521，
而报文段中数据字节数为0

win4096表示发端通告的窗口大小

<mss1024>表示由发端指明的最大报文段长度
选项。发端将不接收超过这个长度的TCP报文段。这通常是为了
避免分段
```

![](http://daheli.qiniudn.com/2017-06-08-14968166916098.jpg)


#### 时间系列
![](http://daheli.qiniudn.com/2017-06-08-14968163004096.jpg)

#### 连接终止协议
![](http://daheli.qiniudn.com/2017-06-08-14968192768392.jpg)

```
建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭
(half-close)造成的。既然一个TCP连接是全双工(即数据在两个方向上能同
时传递)，因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据
发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必
须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进
行关闭的结果。
```
QA: 当服务器发出FIN的ack后,服务器继续向客户端发送数据,客户端如何回应?


### 连接建立的超时
![](http://daheli.qiniudn.com/2017-06-08-14968234809617.jpg)

```
传输层（即 TCP 层）提供可靠的传输，然而，TCP 层依赖的链路本身是不可靠的，TCP 是如何在不可靠的环境中提供可靠服务的呢？答案是超时和重传。TCP 在发送数据时设置一个定时器，当定时器溢出还没有收到 ACK，则重传该数据。因此，超时与重传的关键之处在于如何决定定时器间隔与重传频率。

传统 Unix 实现中，定时器的间隔取决于数据的往返时间（即 RTT），根据 RTT 进行一定的计算得到重传超时间隔（即 RTO）。由于网络路由、流量等的变化，RTT 是经常发生变化的，RTT 的测量也极为复杂（平滑算法、Karn 算法、Jacbson 算法等）
重传的时间间隔，取整后分别为1、3、6、12、24、48和多个64秒。这个倍乘的关系被称为“指数退避”。
```

连接超时重传间隔策略:

* Linux与Android: 指数递增(1,2,4,8,16)
* OPPO:(0.25,0.5,1,2,4,8,16,32,64,64,64…)
* SamSung:(0.42,0.9,1.8,3.7,7.5,15,30,60,120,120…)
* iOS: 优化后的指数递增(1,1,1,1,1,2,4,8,16)


### 复位报文段
```
➜  /tmp curl http://192.168.8.209:8082
curl: (7) Failed to connect to 192.168.8.209 port 8082: Connection refused
```
![](http://daheli.qiniudn.com/2017-06-08-14968279066314.jpg)
* 到不存在的端口的连接请求
* 异常终止一个连接

```
QA: 当一个数据报到达目的端口时,该端口没在使用
TCP则使用复位 / UDP:ICMP端口不可达的信息
```

### QA同时打开/关闭?

## 交互数据流
### 引言
```
如果按照分组数量计算，约有一半的TCP报文段包含成块数据(如FTP、电子邮件和RSS新闻)，另一半则包含交互数据(如Telnet和Rlogin)。如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度(full-sized)的(通常为512字节的用户数据)，而交互数据则小得多(上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节)。很明显，TCP需要同时处理这两类数据，但使用的处理算法则有所不同。
```
### 交互式数据
![](http://daheli.qiniudn.com/2017-06-08-14968402578949.jpg)

```
第1行客户发送字符d到服务器。第2行是该字符的确认及回显(也就是图中间两部
分数据的合并)。第3行是回显字符的确认。与字符a有关的是第4~6行，与字符t
有关的是第7~9行，第10~12行与字符e有关。第3~4、6~7、9~10和12~13行之
间半秒左右的时间差是键入两个字符之间的时延。
```
### 延迟确认
![](http://daheli.qiniudn.com/2017-06-08-14968504026284.jpg)

```
通常TCP在接收到数据时并不立即发送ACK;相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送(有时称这种现象为数据捎带ACK)。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。
不论TCP何时设置一个定时
器，该定时器都可能在将来1~200ms和1~500ms的任一处内核溢出。
```

### Nagle算法
> 在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组:20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组(被称为微小分组(tinygram))通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用
RFC896[Nagle1984]中所建议的Nagle算法。

> 该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组.

![](http://daheli.qiniudn.com/2017-06-08-14968530389498.jpg)

```
其次，注意到从左到右待发数据的长度是不同的，分别为:1、1、2、1、2、2、
3、1和3个字节。这是因为客户只有收到前一个数据的确认后才发送已经收集的
数据。通过使用Nagle算法，为发送16个字节的数据客户只需要使用9个报文
段，而不再是16个
```

```
报文段14和15看起来似乎是与Nagle算法相违背的，但我们需要通过检查序号来
观察其中的真相。因为确认序号是54，因此报文段14是报文段12中确认的应
答。但客户在发送该报文段之前，接收到了来自服务器的报文段13，报文段15中
包含了对序号为56的报文段13的确认。因此即使我们看到从客户到服务器有两个
连续返回的报文段，客户也是遵守了Nagle算法的。
```
```
经受时延的ACK，但该ACK是从服务器到客户的(报文段12)，因为它不包含任何
数据，因此我们可以假定这是经受时延的ACK。服务器当时一定非常忙，因此无
法在服务器的定时器溢出前及时处理所收到的字符。
```

### 窗口大小通告
> 报文段5通告的窗口大小为4095个字节，这意味着在TCP的缓冲区中仍然有一个字节等待应用程序(Rlogin客户)读取。同样，来自客户的下一个报文段声明其窗口大小为4094个字节，这说明仍有两个字节等待读取。

> TCP(报文段18)确认仅仅表明TCP已经正确接收了数据。最后一个报文段的窗口大小为8189而非8192，表明服务器进程尚未读取这三个收到的数据。

## 成块的数据流
### 正常的数据流
![](http://daheli.qiniudn.com/2017-06-08-14969030738242.jpg)

```
三个报文段4、5和6依次到达并按接收顺序放到IP的输入队列。IP将按同样顺序
将它们交给TCP。当TCP处理报文段4时，该连接被标记为产生一个经受时延的确
认。TCP处理下一报文段(5)，由于TCP现在有两个未完成的报文段需要确认，
因此产生一个序号为2048的ACK(报文段7)，并清除该连接产生经受时延的确认
标志。TCP处理下一个报文段(6)，而连接又被标志为产生一个经受时延的确
认。在报文段9到来之前，由于时延定时器溢出，因此产生一个序号为3073的
ACK(报文段8)。报文段8中的窗口大小为3072，表明在TCP的接收缓存中还有
1024个字节的数据等待被应用程序读取。
```
===
**从一个快的发送方到一个慢的接收方**
![](http://daheli.qiniudn.com/2017-06-08-14969056338281.jpg)

```
发送方发送4个背靠背(back-to-back)的数据报文段去填充接收方的窗口，然后停下来等待一个ACK。接收方发送ACK(报文段8)，但通告其窗口大小为0，这说明接收方已收到所有数据，但这些数据都在接收方的TCP缓冲区，因为应用程序还没有机会读取这些数据。另一个ACK(称为窗口更新)在17.4ms后发送，表明接收方现在可以接收另外的4096个字节的数据。虽然这看起来像一个ACK，但由于它并不确认任何新数据，只是用来增加窗口的右边沿，因此被称为窗口更新。
```

### 滑动窗口
**TCP滑动窗口可视化表示**

![](http://daheli.qiniudn.com/2017-06-08-14969061053267.jpg)

> 当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或 减少了窗口的大小。

![](http://daheli.qiniudn.com/2017-06-08-14969067437188.jpg)

> 我们使用三个术语来描述窗口左右边沿的运动:
1) 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。
2) 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发 生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。
3) 当右边沿向左移动时，我们称之为窗口收缩。 Host Requirements RFC强烈建议不要使 用这种方式。

```
如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。
```

####小结与QA
![](http://daheli.qiniudn.com/2017-06-08-14969073321570.jpg)
![](http://daheli.qiniudn.com/2017-06-08-14969074124609.jpg)

```
1) 发送方不必发送一个全窗口大小的数据。
2) 来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对
3) 正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。
4) 接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。
```
### 慢启动

```
迄今为止，在本章所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接 收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。 一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。
```

> TCP需要支持一种被称为“慢启动(slowstart)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。
慢启动为发送方的TCP增加了另一个窗口:拥塞窗口(congestionwindow)，记为cwnd。

```
当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段(即另一端通告的报文段大小)。每收到一个ACK，拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。
```
 > 拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。
### 吞吐量
![](http://daheli.qiniudn.com/2017-06-08-14969119015235.jpg)

```
在时间0，发送方发送了一个报文段。由于发送方处于慢启动中(其拥塞窗口为1个报文段)，因此在继续发送以前它必须等待该数据段的确认。
在时间1,2和3，报文段从左向右移动一个时间单元。在时间4接收方读取这个报文段并产生确认。经过时间5、6和7，ACK移动到左边的发送方。我们有了一个8个时间单元的往返时间RTT(Round-TripTime)。
```

> 通常发送一个分组的时间取决于两个因素:传播时延(由光的有限速率、传输设 备的等待时间等引起)和一个取决于媒体速率(即媒体每秒可传输的比特数)的发送时延。

![](http://daheli.qiniudn.com/2017-06-08-14969121010677.jpg)

```
2个ACK的到达使得拥塞窗口从2个报文段增加为4个，而这4个报文段在时间16~19时被发送。第1个ACK在时间23到达。4个ACK的到达使得拥塞窗口从4个报文段增加为8个，并在时间24~31发送8个报文段。
```
```
在时间31及其后续时间，发送方和接收方之间的管道(pipe)被填满。此时不论拥塞窗口和通告窗口是多少，它都不能再容纳更多的数据。每当接收方在某一个时间单位从网络上移去一个报文段，发送方就再发送一个报文段到网络上。但是不管有多少报文段填充了这个管道，返回路径上总是具有相同数目的ACK。这就是连接的理想稳定状态
```

#### 拥塞

*当数据到达一个大的管道(如一个快速局域网)并向一个较小的管道(如一个较慢的广域网)发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输 入流的总和时也会发生拥塞。*

![](http://daheli.qiniudn.com/2017-06-08-14969122980266.jpg)

```
假定发送方不使用慢启动，它按照局域网的带宽尽可能快地发送编号为1~20的报文段(假定接收方的通告窗口至少为20个报文段)。正如我们看到的那样，ACK之间的间隔与在最慢链路上的一致。假定瓶颈路由器具有足够的容纳这20个分组的缓存。如果这个不能保证，就会引起路由器丢弃分组。
```

## 超时与重传
## 定时器
## 优化
### 引言
![](http://daheli.qiniudn.com/2017-06-08-14968493912238.jpg)
### 建立连接优化
#### 复合连接
#### 旁路检测
### 维持连接优化
#### 混合自动重传请求
#### 合包与动态评估
#### 读写多级超时间隔策略




