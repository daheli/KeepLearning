#TCP协议

##引言
##TCP连接的建立与终止
###连接建立与终止
tcpdump的输出
![](http://daheli.qiniudn.com/2017-06-08-14968166750175.jpg)

```
字段1415531521:1415531521(0)表示分组的序号是1415531521，
而报文段中数据字节数为0

win4096表示发端通告的窗口大小

<mss1024>表示由发端指明的最大报文段长度
选项。发端将不接收超过这个长度的TCP报文段。这通常是为了
避免分段
```

![](http://daheli.qiniudn.com/2017-06-08-14968166916098.jpg)


####时间系列
![](http://daheli.qiniudn.com/2017-06-08-14968163004096.jpg)

####连接终止协议
![](http://daheli.qiniudn.com/2017-06-08-14968192768392.jpg)

```
建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭
(half-close)造成的。既然一个TCP连接是全双工(即数据在两个方向上能同
时传递)，因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据
发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必
须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进
行关闭的结果。
```
QA: 当服务器发出FIN的ack后,服务器继续向客户端发送数据,客户端如何回应?


###连接建立的超时
![](http://daheli.qiniudn.com/2017-06-08-14968234809617.jpg)

```
传输层（即 TCP 层）提供可靠的传输，然而，TCP 层依赖的链路本身是不可靠的，TCP 是如何在不可靠的环境中提供可靠服务的呢？答案是超时和重传。TCP 在发送数据时设置一个定时器，当定时器溢出还没有收到 ACK，则重传该数据。因此，超时与重传的关键之处在于如何决定定时器间隔与重传频率。

传统 Unix 实现中，定时器的间隔取决于数据的往返时间（即 RTT），根据 RTT 进行一定的计算得到重传超时间隔（即 RTO）。由于网络路由、流量等的变化，RTT 是经常发生变化的，RTT 的测量也极为复杂（平滑算法、Karn 算法、Jacbson 算法等）
重传的时间间隔，取整后分别为1、3、6、12、24、48和多个64秒。这个倍乘的关系被称为“指数退避”。
```
连接超时重传间隔策略:
* Linux与Android: 指数递增(1,2,4,8,16)
* OPPO:(0.25,0.5,1,2,4,8,16,32,64,64,64…)
* SamSung:(0.42,0.9,1.8,3.7,7.5,15,30,60,120,120…)
* iOS: 优化后的指数递增(1,1,1,1,1,2,4,8,16)


###复位报文段
```
➜  /tmp curl http://192.168.8.209:8082
curl: (7) Failed to connect to 192.168.8.209 port 8082: Connection refused
```
![](http://daheli.qiniudn.com/2017-06-08-14968279066314.jpg)
* 到不存在的端口的连接请求
* 异常终止一个连接


###QA同时打开/关闭?

##交互数据流
###引言
```
如果按照分组数量计算，约有一半的TCP报文段包含成块数据(如FTP、电子邮件和RSS新闻)，另一半则包含交互数据(如Telnet和Rlogin)。如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度(full-sized)的(通常为512字节的用户数据)，而交互数据则小得多(上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节)。很明显，TCP需要同时处理这两类数据，但使用的处理算法则有所不同。
```
###交互式数据
![](http://daheli.qiniudn.com/2017-06-08-14968402578949.jpg)

```
第1行客户发送字符d到服务器。第2行是该字符的确认及回显(也就是图中间两部分数据的合并)。第3行是回显字符的确认。与字符a有关的是第4~6行，与字符t有关的是第7~9行，第10~12行与字符e有关。第3~4、6~7、9~10和12~13行之间半秒左右的时间差是键入两个字符之间的时延。
```
###延迟确认
![](http://daheli.qiniudn.com/2017-06-08-14968504026284.jpg)

```
通常TCP在接收到数据时并不立即发送ACK;相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送(有时称这种现象为数据捎带ACK)。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。
不论TCP何时设置一个定时
器，该定时器都可能在将来1~200ms和1~500ms的任一处内核溢出。
```

###Nagle算法
在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组:20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组(被称为微小分组(tinygram))通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用
RFC896[Nagle1984]中所建议的Nagle算法。

该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组.

![](http://daheli.qiniudn.com/2017-06-08-14968530389498.jpg)

```
其次，注意到从左到右待发数据的长度是不同的，分别为:1、1、2、1、2、2、3、1和3个字节。这是因为客户只有收到前一个数据的确认后才发送已经收集的数据。通过使用Nagle算法，为发送16个字节的数据客户只需要使用9个报文段，而不再是16个
```

```
报文段14和15看起来似乎是与Nagle算法相违背的，但我们需要通过检查序号来观察其中的真相。因为确认序号是54，因此报文段14是报文段12中确认的应答。但客户在发送该报文段之前，接收到了来自服务器的报文段13，报文段15中包含了对序号为56的报文段13的确认。因此即使我们看到从客户到服务器有两个连续返回的报文段，客户也是遵守了Nagle算法的。
```
```
经受时延的ACK，但该ACK是从服务器到客户的(报文段12)，因为它不包含任何数据，因此我们可以假定这是经受时延的ACK。服务器当时一定非常忙，因此无法在服务器的定时器溢出前及时处理所收到的字符。
```

###窗口大小通告
报文段5通告的窗口大小为4095个字节，这意味着在TCP的缓冲区中仍然有一个字节等待应用程序(Rlogin客户)读取。同样，来自客户的下一个报文段声明其窗口大小为4094个字节，这说明仍有两个字节等待读取。

TCP(报文段18)确认仅仅表明TCP已经正确接收了数据。最后一个报文段的窗口大小为8189而非8192，表明服务器进程尚未读取这三个收到的数据。


##成块的数据流
##超时与重传
##定时器
##优化
###引言
![](http://daheli.qiniudn.com/2017-06-08-14968493912238.jpg)
###建立连接优化
####复合连接
####旁路检测
###维持连接优化
####混合自动重传请求
####合包与动态评估
####读写多级超时间隔策略








